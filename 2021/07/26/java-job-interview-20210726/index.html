<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="准备java后端开发面试的问题">
<meta property="og:type" content="article">
<meta property="og:title" content="java job interview 20210726">
<meta property="og:url" content="http://yoursite.com/2021/07/26/java-job-interview-20210726/index.html">
<meta property="og:site_name" content="如意酿">
<meta property="og:description" content="准备java后端开发面试的问题">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdn.net/2018072110440555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png">
<meta property="article:published_time" content="2021-07-26T14:12:33.000Z">
<meta property="article:modified_time" content="2021-07-29T07:22:09.240Z">
<meta property="article:author" content="Ruyi">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdn.net/2018072110440555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">

<link rel="canonical" href="http://yoursite.com/2021/07/26/java-job-interview-20210726/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>java job interview 20210726 | 如意酿</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">如意酿</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/26/java-job-interview-20210726/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ruyi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如意酿">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java job interview 20210726
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-26 22:12:33" itemprop="dateCreated datePublished" datetime="2021-07-26T22:12:33+08:00">2021-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-07-29 15:22:09" itemprop="dateModified" datetime="2021-07-29T15:22:09+08:00">2021-07-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>准备java后端开发面试的问题 <a id="more"></a></p>
<h2 id="java的基本类型string类型stringbuffer和stringbuffer">java的基本类型，String类型，StringBuffer和StringBuffer</h2>
<p>Java提供了8种基本类型：<code>byte, short, int, long, float, double, boolean, char</code></p>
<p>String类是java中创建和操作字符串的类。属于引用类型。是不可变的。 java中不可变对象的定义： （1）类内部所有的字段都是final修饰的。（2）类内部所有的字段都是私有的，也就是被private修饰。（3）类不能够被集成和拓展。（4）类不能够对外提供哪些能够修改内部状态的方法，setter方法也不行。（5）类内部的字段如果是引用，也就是说可以指向可变对象，那我们程序员不能获取这个应用。</p>
<p>String类用final修饰，并且内容的字符串数组也是<code>private final char value[]</code>(java 1.8),java 9之后改为了`<code>private final char value[]</code>，通常情况下是不能进行修改的。</p>
<p>如何通过反射修改String <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line">String str = <span class="string">&quot;aaaaaaa&quot;</span>;</span><br><span class="line">Field field = String.class.getDeclaredField(&quot;value&quot;);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">char</span> [] value = (<span class="keyword">char</span> []) field.get(str);</span><br><span class="line"><span class="comment">// if java &gt;=1.9, using next line.</span></span><br><span class="line"><span class="comment">// byte [] value = (byte []) field.get(str);</span></span><br><span class="line">value[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure> 为什么java中String类型是不可变的： 第一：在Java程序中String类型是使用最多的，这就牵扯到大量的增删改查，每次增删改差之前其实jvm需要检查一下这个String对象的安全性，就是通过hashcode，当设计成不可变对象时候，就保证了每次增删改查的hashcode的唯一性，也就可以放心的操作。 第二：网络连接地址URL,文件路径path通常情况下都是以String类型保存, 假若String不是固定不变的,将会引起各种安全隐患。就好比我们的密码不能以String的类型保存，，如果你将密码以明文的形式保存成字符串，那么它将一直留在内存中，直到垃圾收集器把它清除。而由于字符串被放在字符串缓冲池中以方便重复使用，所以它就可能在内存中被保留很长时间，而这将导致安全隐患。第三：字符串值是被保留在常量池中的，也就是说假若字符串对象允许改变,那么将会导致各种逻辑错误。</p>
<p>StringBuffer和StringBuilder是字符串修改时使用，修改时对对象本身进行操作，不是生成新的对象。 StringBuffer是线程安全的，StringBuilder不是线程安全的（不能同步访问，但是效率更高</p>
<h2 id="反射机制">反射机制</h2>
<p>反射（Reflection） 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法 可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。 反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。 测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率 Field 类：提供有关类的属性信息，以及对它的动态访问权限。它是一个封装反射类的属性的类。 Constructor 类：提供有关类的构造方法的信息，以及对它的动态访问权限。它是一个封装反射类的构造方法的类。 Method 类：提供关于类的方法的信息，包括抽象方法。它是用来封装反射类方法的一个类。 Class 类：表示正在运行的 Java 应用程序中的类的实例。 Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。</p>
<p>获取字段: <code>getDeclaredFields和getFields</code>，<code>getDeclaredFields</code>用于获取所有声明的字段，包括公有字段和私有字段，<code>getFields</code>仅用来获取公有字段。</p>
<p>获取构造方法: <code>getDeclaredConstructors,getConstructors</code>, 前者用于获取所有构造方法，后者用于获取公有构造方法。</p>
<p>获取非构造方法: <code>getDeclaredMethods, getMethods</code>, <code>getDeclaredMethods</code>无法获取到父类中的方法，<code>getMethods</code>可以获得父类的方法。</p>
<h2 id="动态代理模式">动态代理模式</h2>
<ol type="1">
<li>JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个handler类来实现InvocaionHandler接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHander</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> <span class="title">Throwable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke &quot;</span>  + method.getName());</span><br><span class="line">        method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行动态代理：</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        HelloInterface hello = <span class="keyword">new</span> Hello();</span><br><span class="line">        </span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> ProxyHandler(hello);</span><br><span class="line"></span><br><span class="line">        HelloInterface proxyHello = (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">        proxyHello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>CGlib动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类。</li>
</ol>
<h2 id="java类加载器-双亲委派机制">java类加载器 双亲委派机制</h2>
<p>初始化的时机： 1、遇到new，getstatic、putstatic或者invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已经在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 2、使用过Java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 3、当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 4、当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。</p>
<p>不被初始化的例子 通过子类引用父类的静态字段 (父类会被初始化，子类不会被初始化) 通过数组定义引用类 调用类的常量</p>
<p>类加载：指的是.class文件的加载，可能指一个类也可能是一个接口。类加载的过程：加载-&gt;链接（验证，准备，解析）-&gt;初始化。按谁学开始，各阶段是混合交叉进行的。解析比较特殊，为了支持java语言的晚期绑定/动态绑定，有时解析可以在初始化之后才开始。</p>
<p>加载过程： - 通过一个类的全限定名来获取定义此类的二进制流 - 将这个字节流所代表的静态存储结构转化为方法区运行时的数据存储结构 - 在内存中生成一个代表这个类的Class对象，作为这个类的各种数据访问入口 (注意:HotspotVM会把class对象放在方法区中，而不是堆中)</p>
<p>验证： 目的：确保class文件中的字节流符合当前虚拟机的要求，不会危害虚拟机自身的安全。 包括：文件格式验证，元数据验证，字节码验证，符号引用验证</p>
<p>准备： 目的：为类变量分配内存并且设置类变量初始值的阶段，在方法区进行分配。</p>
<p>解析： 虚拟机将常量池内的符号引用替换为直接引用的过程。解析主要包括：1.类或接口的解析 2.字段解析 3.类方法解析 4.接口方法解析</p>
<p>初始化： 类初始化阶段是类加载过程的最后一步，前面类加载的过程中除了在加载阶段用户应用程序可以通过自定义类加载器参与以外，其余动作完全由虚拟机主导与控制。到了初始化阶段，才是真正执行类中定义的Java程序代码。 在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据开发者通过程序控制指定的主观计划去初始化类变量和其他资源。 初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</p>
<p>类加载器： 虚拟机的设计团队把类加载阶段中的"通过一个类的全限定名来获取描述此类的二进制字节流"这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如果去获取所需要的类。实现这个动作的代码模块称之为类加载器。只有被同一个类加载器加载的类才可能会相等。相同的字节码被不同的类加载器加载的类不相等。</p>
<p>Bootstrap ClassLoader： Java虚拟机的一部分，使用C++编写，没有父类，用于加载java_home下的lib目录下的包，比如：rt.jar（包括java中的各种核心的类，比如java.lang）</p>
<p>Extension ClassLoader： 扩展类加载器，java实现，父类为null，加载lib/ext目录中的类</p>
<p>Application ClassLoader： 系统类加载器，由Java语言实现，父类加载器为扩展类加载器，加载用户路径(ClassPath)上所指定的类库</p>
<p>自定义类加载器： 父类加载器是：<code>AppClassLoader</code>，使用过程中继承<code>AppClassLoader</code>, 重写<code>loadClass()</code>方法，示例化Class对象</p>
<p>双亲委派： 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成 每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器 如果顶层的启动类加载器加载器无法完成加载请求时，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载。</p>
<p>特点：java的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了Java程序的稳定运行 <img src="https://img-blog.csdn.net/2018072110440555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0Y2F0c19jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="类加载器（摘自CSDN）" /></p>
<h2 id="java-class对象">java Class对象</h2>
<p>java有两种对象：实例对象和Class对象。每个类的运行时的类型信息就是用Class对象表示的。它包含了与类有关的信息。其实我们的实例对象就通过Class对象来创建的。Java使用Class对象执行其RTTI（运行时类型识别，Run-Time Type Identification），多态是基于RTTI实现的。 每一个类都有一个Class对象，每当编译一个新类就产生一个Class对象，基本类型，void也有Class对象。 有三种获得Class对象的方式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;java.lang.String&quot;</span>) <span class="comment">//完整路径获得</span></span><br><span class="line">str.getClass() <span class="comment">// 对象的getClass函数</span></span><br><span class="line">String.class  // 类的class属性</span><br></pre></td></tr></table></figure></p>
<h2 id="java-多态的实现原理">java 多态的实现原理</h2>
<p>多态就是指一个引用变量可以指向该类和该类的子类的对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 多态存在的三个必要条件 继承，重写，父类引用指向子类对象：Parent p = new Child();</p>
<p>实现方式：重写，接口，抽象类和抽象方法 原理：通过动态绑定实现，主要用到的是Class对象的方法表，在调用某个对象方法时，JVM查找方法表来确定直接引用地址，不同对象会指向不同的方法。</p>
<h2 id="hashmap和concurrentthashmap">HashMap和concurrentthashmap</h2>
<p>由于HashMap是线程不同步的，虽然处理数据的效率高，但是在多线程的情况下存在着安全问题，因此设计了CurrentHashMap来解决多线程安全问题。</p>
<p>HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触<strong>发扩容操作</strong>，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<p>HashMap的环：若当前线程此时获得ertry节点，但是被线程中断无法继续执行，此时线程二进入transfer函数，并把函数顺利执行，此时新表中的某个位置有了节点，之后线程一获得执行权继续执行，因为并发transfer，所以两者都是扩容的同一个链表，当线程一执行到e.next = new table[i] 的时候，由于线程二之前数据迁移的原因导致此时new table[i] 上就有ertry存在，所以线程一执行的时候，会将next节点，设置为自己，导致自己互相使用next引用对方，因此产生链表，导致死循环。</p>
<p>在JDK1.7版本中，ConcurrentHashMap维护了一个Segment数组，Segment这个类继承了重入锁ReentrantLock，并且该类里面维护了一个 HashEntry&lt;K,V&gt;[] table数组，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。在JDK1.8版本中，ConcurrentHashMap摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap。</p>
<h2 id="锁机制读写锁-乐观锁-悲观锁-aqs-自旋锁">锁机制，读写锁, 乐观锁, 悲观锁, AQS, 自旋锁</h2>
<p>死锁的条件： 互斥，不可剥夺，请求与保持，循环等待</p>
<figure>
<img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="Java中的锁" /><figcaption aria-hidden="true">Java中的锁</figcaption>
</figure>
<p>悲观锁：总认为最坏的情况可能会出现，它认为数据很可能会被其他人所修改，所以悲观锁在持有数据的时候总会把资源 或者 数据 锁住，这样其他线程想要请求这个资源的时候就会阻塞，直到等到悲观锁把资源释放为止。<code>Synchronized, ReentrantLock</code>等独占锁就是一种悲观锁的实现。</p>
<p>乐观锁：总认为资源和数据不会被别人所修改，所以读取不会上锁。乐观锁多适用于多读的应用类型，这样可以提高吞吐量。 实现方案一般来说有两种：版本号机制 和 CAS实现。 <code>java.util.concurrent.AtomicInteger</code>是CAS的一种实现。 属于自选锁的一种，失败触发等待重试机制。</p>
<p>没有获取到锁的线程通常有两种处理方式：一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)；还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</p>
<p>自旋锁：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock) 自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，操作系统的内核经常使用自旋锁。无法保证多线程竞争的公平性</p>
<p>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列（虚拟的双向队列）的一个结点（Node），来实现锁的分配。 AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<p>读写锁： <code>ReetrantReadWriteLock</code>，包括<code>readLock(), writeLock()</code>返回Lock对象，一个只用于读操作，一个只用于写操作，允许多个程序进行读，写锁是独占的。当有读锁时，写锁就不能获得；而当有写锁时，除了获得写锁的这个线程可以获得读锁外，其他线程不能获得读锁</p>
<h2 id="synchronized-volatile关键字-lock接口-reentrantlock类-cas的含义和问题">Synchronized, volatile关键字, Lock接口, ReentrantLock类, cas的含义和问题</h2>
<p>java 锁是基于对象的。 synchronized锁的升级： 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的。 Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。 Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步（重量级锁）。JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”</p>
<p>volatile在多处理器开发中保证了共享变量的“ 可见性”。可见性的意思是当一个线程修改一个共享变量时（写回主内存），另外一个线程能读到这个修改的值。(共享内存，私有内存)</p>
<p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。如 Intel 处理器，比较并交换通过指令的 cmpxchg 系列实现。 ABA问题： 如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p>
<h2 id="java的线程模型">java的线程模型</h2>
<p>Java默认使用的是一对一模型。轻量级进程（LWP），系统提供给用户的操作内核线程的接口的实现。即轻量级进程是内核线程的一个替身。每个LWP都是独立的调度单元，一个线程阻塞不影响其他线程。Java采用抢占式调度。同时Java定义了线程优先级。可以在一定程度上调整线程的CPU时间。Java采用的是共享内存并发模型。</p>
<p>Java内存模型（JMM）中，可以将虚拟机内存划分为两部分内存：主内存和线程工作内存，主内存是多个线程共享的内存，线程工作内存是每个线程独享的内存。 Java内存模型定义了8种原子操作，此外Java内存模型还保证了对于基本数据类型（char、boolean、int等）的操作是原子性的。对于其他类型的数据如若需要更灵活的原子性操作，Java内存模型提供了lock和unlock操作。JVM中使用的两个字节码指令monitorenter和monitorexit即是通过lock和unlock操作来实现的，常使用的synchronized关键字转换成字节码指令后即由monitorenter和monitorexit构成。</p>
<p>Java内存模型规定<strong>所有的变量都存储在主内存</strong>中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，<strong>线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行，不能直接读写主内存中的变量</strong>。当线程改变工作内存某个变量值的时候，会写回主内存中的值，主内存通过<strong>volatile关键字</strong>通知其他含有该变量的线程。整个Java内存模型实际上是围绕着三个特征建立起来的。分别是：<strong>原子性，可见性，有序性</strong>。这三个特征可谓是整个Java并发的基础。</p>
<h2 id="java内存区域划分">java内存区域划分</h2>
<ol type="1">
<li>程序计数器 程序计数器是线程私有的内存区域，唯一一个没有规定任何OutOfMemoryError情况的区域</li>
<li>Java虚拟机栈 线程私有的 Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</li>
<li>本地方法栈 本地方法栈为虚拟机使用到的Native方法服务</li>
<li>Java堆 所有的线程共享的一块内存区域，在虚拟机启动时创建，是垃圾回收器管理的主要区域。 Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</li>
<li>方法区 线程共享的一块内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 <em>运行时常量池</em>，具备动态性，String类的intern()方法，将新的常量放入池中</li>
</ol>
<h2 id="java-gc">java GC</h2>
<p>垃圾回收算法： 1. 停止-复制：先暂停程序的运行,然后将所有存活的对象从当前堆复制到另一个堆,没有被复制的对象全部都是垃圾。当对象被复制到新堆时,它们是一个挨着一个的,所以新堆保持紧凑排列,然后就可以按前述方法简单,直接的分配了。缺点是一浪费空间,两个堆之间要来回倒腾,二是当程序进入稳定态时,可能只会产生极少的垃圾,甚至不产生垃圾,尽管如此,复制式回收器仍会将所有内存自一处复制到另一处。 2. 标记-清除：同样是从堆栈和静态存储区出发,遍历所有的引用,进而找出所有存活的对象。每当它找到一个存活的对象,就会给对象一个标记,这个过程中不会回收任何对象。只有全部标记工作完成的时候,清理动作才会开始。在清理过程中,没有标记的对象会被释放,不会发生任何复制动作。所以剩下的堆空间是不连续的,垃圾回收器如果要希望得到连续空间的话,就得重新整理剩下的对象。 3. 标记-整理：它的第一个阶段与标记/清除算法是一模一样的，均是遍历GC Roots，然后将存活的对象标记。移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。因此，第二阶段才称为整理阶段。 4. 分代收集算法：把Java堆分为新生代和老年代，然后根据各个年代的特点采用最合适的收集算法。新生代中，对象的存活率比较低，所以选用复制算法，老年代中对象存活率高且没有额外空间对它进行分配担保，所以使用“标记-清除”或“标记-整理”算法进行回收。</p>
<p>Minor GC和Full GC触发条件 * Minor GC触发条件：当Eden区满时，触发Minor GC。 * Full GC触发条件： 1. 调用System.gc时，系统建议执行Full GC，但是不必然执行 2. 老年代空间不足 3. 方法区空间不足 4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<p>GC Roots 1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。 2. 方法区中类静态属性引用的对象。 3. 方法区中常量引用的对象。 4. 本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
<p>CMS的执行过程 1. 初始标记(STW initial mark)：这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。 2. 并发标记(Concurrent marking)：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。 3. 并发预清理(Concurrent precleaning)：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。 4. 重新标记(STW remark)：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"跟对象"开始向下追溯，并处理对象关联。 5. 并发清理(Concurrent sweeping)：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。 6. 并发重置(Concurrent reset)：这个阶段，重置CMS收集器的数据结构状态，等待下一次垃圾回收。</p>
<h2 id="java的线程池">java的线程池</h2>
<p>线程池的优点： 1. 减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2. 可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下。</p>
<p>核心线程池ThreadPoolExecutor内部参数 1. corePoolSize：指定了线程池中的线程数量 2. maximumPoolSize：指定了线程池中的最大线程数量 3. keepAliveTime：线程池维护线程所允许的空闲时间 4. unit: keepAliveTime 的单位。 5. workQueue：任务队列，被提交但尚未被执行的任务。 6. threadFactory：线程工厂，用于创建线程，一般用默认的即可。 7. handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。</p>
<p>线程池的执行流程 1. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务 2. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列 3. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务 4. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException</p>
<p>线程池的工作队列: 1. ArrayBlockingQueue：底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。 2. LinkedBlockingQueue：底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。 3. SynchronousQueue：本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。 4. PriorityBlockingQueue：无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</p>
<h2 id="spring-ioc-和aop的理解">Spring IOC 和AOP的理解</h2>
<p>控制反转（IoC）和面向切面编程（AOP） IoC就是对象的创建，依赖都由Spring及配置文件控制 AOP就是统一的给一些类似的方法加上同样的功能，比如日志，事务。 IOC就是典型的工厂模式，通过sessionfactory去注入实例。 AOP就是典型的代理模式的体现。</p>
<h2 id="设计模式springboot中的设计模式">设计模式，SpringBoot中的设计模式</h2>
<pre><code>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；

单例模式：Bean默认为单例模式。

代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；

模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。

观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</code></pre>
<h2 id="单例模式">单例模式</h2>
<p>参考<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a></p>
<p>饿汉式，多线程安全，类加载时就初始化，Lazy初始化：否 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双重校验锁 多线程安全，Lazy初始化：是 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>( Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        retunr singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 枚举 Lazy初始化：否，多线程初始化：是 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubic <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事务机制和springbootmysql数据库中的实现和底层原理">事务机制和SpringBoot,Mysql数据库中的实现和底层原理</h2>
<p>事务：ACID A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</p>
<p>并发事务出现的问题： 1、脏读：对于任意两个事务：T1、T2。T1读取了已经被T2 更新但还没有提交的字段之后，若 T2 回滚， T1 读取到的内容是临时且无效的。读取了事务执行过程中的中间数据。 2、不可重复读：对于两个事务 T1、T2 。T1 读取了一个字段，然后T2 更新了该字段之后，T1 再次读取同一个字段，值就不同了。在同一个事务中，受其他事务更新影响，两次读取的数据不一致。 3、幻读：对于两个事务 T1、T2。T1 读取一张表，然后 T2 在该表中插入了一些新的记录。之后，如果 T1 再次读取同一张表，就会多出几行。在同一个事务中，受其他事务插入删除影响，两次读取的记录数量有变化。</p>
<p>Mysql的事务隔离级别有： 读未提交、读已提交、可重复读（Mysql默认）、串行化 修改命令: <code>SET GLOBAL  TRANSACTION ISOLATION LEVEL XXX)</code></p>
<p>隔离级别与并发问题的关系： |*|脏读|不可重复读|幻读| |--|--|--|--| |READ-UNCOMMITTED|出现|出现|出现| |READ-COMMITTED(Oracle默认)|解决|出现|出现| |REPEATABLE-READ(MySQL默认)|解决|解决|出现| |SERIALIZABLE|解决|解决|解决|</p>
<p>MySQL的InnoDB引擎来说，事务的隔离性是通过锁来实现的，在锁的相关文章已经详细说明。原子性、一致性、持久性是通过数据的redo log和undo log来完成的。 redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。因此两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。redo log用来实现事务的持久性和一致性，它由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），其是持久的。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。 undo主要用于回滚和实现MCVV，它是在用户执行事务时，由于某种原因失败，又或者有一个rollback语句请求回滚，就可以利用这些undo信息将数据回滚到修改前的样子。undo存放在数据库内部的一个特殊字段中，这个段叫做undo段，位于共享表空间中。注意undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有的修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。 前面还说到MCVV是通过undo来完成的。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以实现非锁定读取。最后，undo log会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。 InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>
<p>SprintBoot 提供插件@Transactional 来实现事务机制</p>
<p>Spring中的事务传播机制 1. REQUIRED（默认，常用）：支持使用当前事务，如果当前事务不存在，创建一个新事务。eg:方法B用REQUIRED修饰，方法A调用方法B，如果方法A当前没有事务，方法B就新建一个事务（若还有C则B和C在各自的事务中独立执行），如果方法A有事务，方法B就加入到这个事务中，当成一个事务。 2. SUPPORTS：支持使用当前事务，如果当前事务不存在，则不使用事务。 3. MANDATORY：强制，支持使用当前事务，如果当前事务不存在，则抛出Exception。 4. REQUIRES_NEW（常用）：创建一个新事务，如果当前事务存在，把当前事务挂起。eg:方法B用REQUIRES_NEW修饰，方法A调用方法B，不管方法A上有没有事务方法B都新建一个事务，在该事务执行。 5. NOT_SUPPORTED：无事务执行，如果当前事务存在，把当前事务挂起。 6. NEVER：无事务执行，如果当前有事务则抛出Exception。 7. NESTED：嵌套事务，如果当前事务存在，那么在嵌套的事务中执行。如果当前事务不存在，则表现跟REQUIRED一样。</p>
<p><span class="citation" data-cites="Transactional错误使用失效场景">@Transactional错误使用失效场景</span> 1. <span class="citation" data-cites="Transactional">@Transactional</span> 在private上：当标记在protected、private、package-visible方法上时，不会产生错误，但也不会表现出为它指定的事务配置。可以认为它作为一个普通的方法参与到一个public方法的事务中。 2. <span class="citation" data-cites="Transactional">@Transactional</span> 的事务传播方式配置错误。 3. <span class="citation" data-cites="Transactional">@Transactional</span> 注解属性 rollbackFor 设置错误：Spring默认抛出了未检查unchecked异常（继承自 RuntimeException 的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。 4. 同一个类中方法调用，导致@Transactional失效：由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。 5. 异常被 catch 捕获导致@Transactional失效。 6. 数据库引擎不支持事务。</p>
<h2 id="springboot的自动配置">SpringBoot的自动配置</h2>
<p><span class="citation" data-cites="SpringBootApplication是一个复合注解或派生注解">@SpringBootApplication是一个复合注解或派生注解</span>，在@SpringBootApplication中有一个注解<span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span>。这个注解也是一个派生注解，其中的关键功能由@Import提供，其导入的AutoConfigurationImportSelector的selectImports()方法通过SpringFactoriesLoader.loadFactoryNames()扫描所有具有META-INF/spring.factories的jar包。 spring.factories文件也是一组一组的key=value的形式，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表，这些类名以逗号分隔， <span class="citation" data-cites="EnableAutoConfiguration注解通过">@EnableAutoConfiguration注解通过</span><span class="citation" data-cites="SpringBootApplication被间接的标记在了Spring">@SpringBootApplication被间接的标记在了Spring</span> Boot的启动类上。在SpringApplication.run(...)的内部就会执行selectImports()方法，找到所有JavaConfig自动配置类的全限定名对应的class，然后将所有自动配置类加载到Spring容器中</p>
<p>Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中的所有自动配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过以Properties结尾命名的类中取得在全局配置文件中配置的属性如：server.port，而XxxxProperties类是通过@ConfigurationProperties注解与全局配置文件中对应的属性进行绑定的。</p>
<p><span class="citation" data-cites="EnableAutoConfigration">@EnableAutoConfigration</span> 注解会导入一个自动配置选择器去扫描每个jar包的META-INF/xxxx.factories 这个文件，这个文件是一个key-value形式的配置文件，里面存放了这个jar包依赖的具体依赖的自动配置类。这些自动配置类又通过@EnableConfigurationProperties 注解支持通过xxxxProperties 读取application.properties/application.yml属性文件中我们配置的值。如果我们没有配置值，就使用默认值，这就是所谓约定&gt;配置的具体落地点。</p>
<p>XxxxProperties类的含义是：封装配置文件中相关属性；XxxxAutoConfiguration类的含义是：自动配置类，目的是给容器中添加组件</p>
<p>参考： <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-basic-datatypes.html">菜鸟教程</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75577371">知乎专栏：面试必问：Java中String类型为什么设计成不可变的？</a> <a target="_blank" rel="noopener" href="https://www.w3cschool.cn/java/java-reflex.html">w3cschool.cn</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44670213">知乎专栏：Java虚拟机——类加载机制和类加载器</a> <a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/itcats_cn/article/details/81128783">CSDN itcats_cn</a> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkwMDE1MzkwNQ==&amp;mid=2247496062&amp;idx=1&amp;sn=c04e0b83f38c45d06538ebac69529ee1&amp;source=41#wechat_redirect">看完你就应该能明白的悲观锁和乐观锁</a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/cxuanBlog/p/11679883.html">看完你就明白的锁系列之自旋锁</a> <a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c77f6d22d212">Java线程模型</a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/jqctop1/p/9538316.html">Java 线程模型</a> <a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">新一代垃圾回收器ZGC的探索与实践</a> <a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java中9种常见的CMS GC问题分析与解决</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86293659">详解面试中常考的 Java 反射机制</a> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9bcac608c714">JAVA动态代理</a> <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com">廖雪峰</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/u014745069/article/details/83820511">CSDN博主「圣斗士Morty」</a> <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344">Spring事务传播行为详解</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/19/tqdm-some-notes/" rel="prev" title="tqdm 使用">
      <i class="fa fa-chevron-left"></i> tqdm 使用
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8Bstring%E7%B1%BB%E5%9E%8Bstringbuffer%E5%92%8Cstringbuffer"><span class="nav-number">1.</span> <span class="nav-text">java的基本类型，String类型，StringBuffer和StringBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">反射机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">动态代理模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">java类加载器 双亲委派机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-class%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">java Class对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">java 多态的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashmap%E5%92%8Cconcurrentthashmap"><span class="nav-number">7.</span> <span class="nav-text">HashMap和concurrentthashmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%BB%E5%86%99%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81-aqs-%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">锁机制，读写锁, 乐观锁, 悲观锁, AQS, 自旋锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized-volatile%E5%85%B3%E9%94%AE%E5%AD%97-lock%E6%8E%A5%E5%8F%A3-reentrantlock%E7%B1%BB-cas%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">Synchronized, volatile关键字, Lock接口, ReentrantLock类, cas的含义和问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">java的线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="nav-number">11.</span> <span class="nav-text">java内存区域划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-gc"><span class="nav-number">12.</span> <span class="nav-text">java GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">13.</span> <span class="nav-text">java的线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-ioc-%E5%92%8Caop%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">14.</span> <span class="nav-text">Spring IOC 和AOP的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fspringboot%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">设计模式，SpringBoot中的设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E5%92%8Cspringbootmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">17.</span> <span class="nav-text">事务机制和SpringBoot,Mysql数据库中的实现和底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">18.</span> <span class="nav-text">SpringBoot的自动配置</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ruyi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ruyi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
